#include <msp430.h>
#include <stdint.h>
#include <stdlib.h>
#include "inc\hw_memmap.h"
#include "driverlibHeaders.h"
#include "CTS_Layer.h"

#include "grlib.h"
#include "LcdDriver/Dogs102x64_UC1701.h"
#include "peripherals.h"
#include <time.h>

#define MAX_LEVELS 3
#define XX 1
#define SQUARE 2
#define OCT 4
#define TRI 8
#define CIRCLE 16

#define XX_LIGHT LED8
#define SQUARE_LIGHT LED7
#define OCT_LIGHT LED6
#define TRI_LIGHT LED5
#define CIRCLE_LIGHT LED4

#define GREEN 8
#define RED 2
#define BUTTON_1 2
#define ORANGE 4
#define BUTTON_2 4
#define ALL 14
#define NOTES_IN_SONG 51

enum state { //create enumeration
	start ,
	play ,
	success ,
	failure
} game_state ;

struct _NoteData{
	int pitch ;
	unsigned int duration ;
	char LED ;
	int touchPad ;
};

typedef struct _NoteData NoteData ;

unsigned int timer ; //global timer count variable
unsigned int leap_cnt = 0 ; //global interrupt count variable

//prototypes
void countdown(void) ;
char configureButtons(void) ;
void configLED1_3(char inbits) ;
void runtimerA2(void) ;
void stoptimerA2(int i) ;
void displayNote(NoteData Notes[], int i) ;

void main(void){
	NoteData Bf ;
	Bf.pitch = 70 ;
	Bf.duration = 100 ;
	Bf.LED = XX_LIGHT ;
	Bf.touchPad = XX ;

	NoteData C1 ;
	C1.pitch = 63 ;
	C1.duration = 100 ;
	C1.LED = SQUARE_LIGHT ;
	C1.touchPad = SQUARE ;

	NoteData D ;
	D.pitch = 56 ;
	D.duration = 100 ;
	D.LED = SQUARE_LIGHT ;
	D.touchPad = SQUARE ;

	NoteData Ef ;
	Ef.pitch = 53 ;
	Ef.duration = 100 ;
	Ef.LED = OCT_LIGHT ;
	Ef.touchPad = OCT ;

	NoteData Ef300 ;
	Ef300.pitch = 53 ;
	Ef300.duration = 300 ;
	Ef300.LED = OCT_LIGHT ;
	Ef300.touchPad = OCT ;

	NoteData Ef400 ;
	Ef400.pitch = 53 ;
	Ef400.duration = 400 ;
	Ef400.LED = OCT_LIGHT ;
	Ef400.touchPad = OCT ;

	NoteData F ;
	F.pitch = 47 ;
	F.duration = 100 ;
	F.LED = TRI_LIGHT ;
	F.touchPad = TRI ;

	NoteData G ;
	G.pitch = 42 ;
	G.duration = 100 ;
	G.LED = TRI_LIGHT ;
	G.touchPad = TRI ;

	NoteData G500 ;
	G500.pitch = 42 ;
	G500.duration = 500 ;
	G500.LED = TRI_LIGHT ;
	G500.touchPad = TRI ;

	NoteData G600 ;
	G600.pitch = 42 ;
	G600.duration = 600 ;
	G600.LED = TRI_LIGHT ;
	G600.touchPad = TRI ;

	NoteData Bfh ;
	Bfh.pitch = 35 ;
	Bfh.duration = 100 ;
	Bfh.LED = CIRCLE_LIGHT ;
	Bfh.touchPad = CIRCLE ;

	NoteData Ch ;
	Ch.pitch = 31 ;
	Ch.duration = 100 ;
	Ch.LED = CIRCLE_LIGHT ;
	Ch.touchPad = CIRCLE ;

	NoteData c ;
	c.pitch = 63 ;
	c.duration = 200 ;
	c.LED = SQUARE_LIGHT ;
	c.touchPad = SQUARE ;

	NoteData d ;
	d.pitch = 56 ;
	d.duration = 200 ;
	d.LED = SQUARE_LIGHT ;
	d.touchPad = SQUARE ;

	NoteData ef ;
	ef.pitch = 53 ;
	ef.duration = 200 ;
	ef.LED = OCT_LIGHT ;
	ef.touchPad = OCT ;

	NoteData f ;
	f.pitch = 47 ;
	f.duration = 200 ;
	f.LED = TRI_LIGHT ;
	f.touchPad = TRI ;

	NoteData AfL ;
	AfL.pitch = 79 ;
	AfL.duration = 400 ;
	AfL.LED = XX_LIGHT ;
	AfL.touchPad = XX ;

	NoteData hold ;
	hold.pitch = 0;
	hold.duration = 50 ;
	hold.LED =  0 ;
	hold.touchPad = 0 ;

	//make sure to alter NOTES_IN_SONG after every change
	NoteData Notes[] = {hold, hold, hold, c, hold, C1, Bf, c, hold, C1, Bf, c, hold, C1, Bf, AfL,
			Ef, G, Bf, G500, F, Ef, G, F, Ef300,
			d, F, F, f, F, G, F, Ef400, hold, ef, G, Bfh, Ch, G, F, Ef,
			G, f, F, ef, C1, ef, f, F, Ef, G600, hold, hold, hold} ;
	//enable global interrupts
	_BIS_SR(GIE) ;

	//stop watchdog
	WDTCTL = WDTPW | WDTHOLD;		// Stop watchdog timer

	//Perform initializations (see peripherals.c)
	configTouchPadLEDs();
	configDisplay();
	configCapButtons();

	// Variable to record button state for later
    CAP_BUTTON keypressed_state;

    int gameover = 0 ; //flag for ending game
    char button = 0 ;
    char S1 = 0 ;
    char S2 = 0 ;
    int screenCount = 1 ;
    int i = 0 ; //loop counter
    int reset = 0 ; //flag to reset program immediately
    int missed = 0 ; //flag for time allowed to hit touchPad
    int played = 0 ; //holds whether or not note was played at all
    int letGo = 0 ; //flag to tell whether or not note was played and then finger removed prior to end of note
    int totalMissed = 0 ;

	game_state = start ;

	P1OUT &= ~(LED4+LED5+LED6+LED7+LED8);   // turn off all 5 LEDs

	while(1){
		//switch case
		switch(game_state){
			case start: //Display welcome screen
				//reset all values
				button = 0 ;
				reset = 0 ;

				// Intro Screen -- Write to the display screen
				if(screenCount){
					GrClearDisplay(&g_sContext) ;
					GrStringDrawCentered(&g_sContext, "MSP430", AUTO_STRING_LENGTH, 51, 6, TRANSPARENT_TEXT);
					GrStringDrawCentered(&g_sContext, "HERO", AUTO_STRING_LENGTH, 51, 18, TRANSPARENT_TEXT);
					GrStringDrawCentered(&g_sContext, "By Kyle Young", AUTO_STRING_LENGTH, 51, 30, TRANSPARENT_TEXT);
					GrStringDrawCentered(&g_sContext, "& Yue Li", AUTO_STRING_LENGTH, 51, 42, TRANSPARENT_TEXT);
					GrStringDrawCentered(&g_sContext, "Press S1", AUTO_STRING_LENGTH, 51, 54, TRANSPARENT_TEXT);
					screenCount-- ;
				}

		    	// Refresh the display now that we have finished writing to it
		    	GrFlush(&g_sContext);
		    	totalMissed = 0 ;

		    	S1 = configureButtons() ;
		    	if(S1 == BUTTON_1){
		    		S1 = 0 ;
		    		countdown() ;
		    		configLED1_3(!(ALL)) ;
		    		game_state = play ;
		    	}

		    	break ;

		    case play: //Check Cap Pads
		    	screenCount++ ;
	    		GrClearDisplay(&g_sContext) ;

		    	for(i = 0; i < NOTES_IN_SONG; i++){
		    		stoptimerA2(0) ;
		    		runtimerA2() ;
		    		displayNote(Notes, i) ;
		    		while(timer < Notes[i].duration && reset == 0){
		    			P1OUT |= Notes[i].LED ;

		    			//configure LEDs to display how many errors
		    			if(totalMissed == 0){
		    				configLED1_3(GREEN) ;
		    			}
		    			else if(totalMissed == 1){
		    				configLED1_3(ORANGE) ;
		    			}
		    			else if (totalMissed == 2){
		    				configLED1_3(RED) ;
		    			}

		    			keypressed_state = CapButtonRead() ;
		    			if(totalMissed == 3 && timer >= Notes[i].duration - 10){
		    				game_state = failure ;
		    				reset = 1 ;
		    				break ;
		    			}
		    			if(keypressed_state == Notes[i].touchPad && missed == 0 && letGo == 0){
		    				BuzzerOn(Notes[i].pitch) ;
		    				played = 1 ;
		    			}
		    			else if(played == 1 && keypressed_state != Notes[i].touchPad){
		    				BuzzerOff() ;
		    				letGo = 1 ;
		    			}
		    			else if(keypressed_state != Notes[i].touchPad && Notes[i].touchPad != 0 && timer > 25 && played == 0){
		    				BuzzerOn(Notes[i].pitch - (rand() % 10 + 5)) ;
		    				if(missed == 0){
		    					totalMissed++ ;
		    				}
		    				missed = 1 ;
		    			}

		    			//reset button
		    			S2 = configureButtons() ;
		    			if(S2 == BUTTON_2){
		    				game_state = start ;
		    				reset = 1 ;
		    				BuzzerOff() ;
		    				P1OUT &= ~Notes[i].LED ;
		    			}
		    		}
		    		if(reset == 1){
		    			break ;
		    		}
		    		if(i == (NOTES_IN_SONG - 1) && totalMissed < 3){
		    			game_state = success ;
		    		}
		    		BuzzerOff() ;
		    		played = 0 ;
		    		missed = 0 ;
		    		letGo = 0 ;
		    		P1OUT &= ~(Notes[i].LED) ;

		    	}

		    	configLED1_3(~(ALL)) ;

		    	//reset button
		    	S2 = configureButtons() ;
		    	if(S2 == BUTTON_2){
		    		game_state = start ;
		    		reset = 1 ;
		    	}


		    	button = configureButtons() ;
		    	//configLED1_3(button) ;
		    	keypressed_state = CapButtonRead() ;

		    	break ;

		    case success: //displays success and starts next level unless it was last level
		    	if(totalMissed == 0){
		    		GrClearDisplay(&g_sContext) ;
		    		GrStringDrawCentered(&g_sContext, "Perfect!", AUTO_STRING_LENGTH, 51, 15, TRANSPARENT_TEXT);
		    		GrStringDrawCentered(&g_sContext, "No Misses!", AUTO_STRING_LENGTH, 51, 34, TRANSPARENT_TEXT);
		    		GrStringDrawCentered(&g_sContext, "Press S2", AUTO_STRING_LENGTH, 51, 53, TRANSPARENT_TEXT);
		    		GrFlush(&g_sContext) ;
		    	}
		    	else if(totalMissed == 1){
		    		GrClearDisplay(&g_sContext) ;
		    		GrStringDrawCentered(&g_sContext, "Good Job!", AUTO_STRING_LENGTH, 51, 15, TRANSPARENT_TEXT);
		    		GrStringDrawCentered(&g_sContext, "Missed 1", AUTO_STRING_LENGTH, 51, 34, TRANSPARENT_TEXT);
		    		GrStringDrawCentered(&g_sContext, "Press S2", AUTO_STRING_LENGTH, 51, 53, TRANSPARENT_TEXT);
		    		GrFlush(&g_sContext) ;
		    	}
		    	else if(totalMissed == 2){
		    		GrClearDisplay(&g_sContext) ;
		    		GrStringDrawCentered(&g_sContext, "I've Seen Better", AUTO_STRING_LENGTH, 51, 15, TRANSPARENT_TEXT);
		    		GrStringDrawCentered(&g_sContext, "Missed 2", AUTO_STRING_LENGTH, 51, 34, TRANSPARENT_TEXT);
		    		GrStringDrawCentered(&g_sContext, "Press S2", AUTO_STRING_LENGTH, 51, 53, TRANSPARENT_TEXT);
		    		GrFlush(&g_sContext) ;
		    	}

			    	//reset button
			    	S2 = configureButtons() ;
			    	if(S2 == BUTTON_2){
			    		game_state = start ;
			    	}

		    	break ;

		    case failure: //displays failure and then welcome screen
		    	BuzzerOff() ;
		    	P1OUT &= ~Notes[i].LED ;
		    	GrClearDisplay(&g_sContext) ;
		    	GrStringDrawCentered(&g_sContext, "GAME OVER!", AUTO_STRING_LENGTH, 51, 22, TRANSPARENT_TEXT);
		    	GrStringDrawCentered(&g_sContext, "Press S2", AUTO_STRING_LENGTH, 51, 46, TRANSPARENT_TEXT);
		    	GrFlush(&g_sContext) ;

		    	//reset button
		    	S2 = configureButtons() ;
		    	if(S2 == BUTTON_2){
		    		game_state = start ;
		    	}

		    	break ;
		}
	}
}

void countdown(void){
	int counter = 1 ;
	stoptimerA2(1) ; //resets timer
	runtimerA2() ; //starts timer

	while(counter){
		GrClearDisplay(&g_sContext) ;
		if(timer < 200){
			GrStringDrawCentered(&g_sContext, "3", AUTO_STRING_LENGTH, 51, 22, TRANSPARENT_TEXT);
			configLED1_3(RED) ;
		}
		else if(timer < 400){
			GrStringDrawCentered(&g_sContext, "2", AUTO_STRING_LENGTH, 51, 22, TRANSPARENT_TEXT);
			configLED1_3(ORANGE) ;
		}
		else if(timer < 600){
			GrStringDrawCentered(&g_sContext, "1", AUTO_STRING_LENGTH, 51, 22, TRANSPARENT_TEXT);
			configLED1_3(GREEN) ;
		}
		else if(timer < 800){
			GrStringDrawCentered(&g_sContext, "GO!", AUTO_STRING_LENGTH, 51, 22, TRANSPARENT_TEXT);
			configLED1_3(ALL) ;
		}
		else if(timer < 1000){
			counter = 0 ;
		}

		GrFlush(&g_sContext) ;
	}
}

char configureButtons(void){
	//select pins to be digital IO
	P1SEL &= ~BIT7 ;
	P2SEL &= ~BIT2 ;

	//select pins to be inputs
	P1DIR &= ~BIT7 ;
	P2DIR &= ~BIT2 ;

	//enable pullup resistor
	P1REN |= BIT7 ;
	P2REN |= BIT2 ;

	//set to be pullup
	P1OUT |= BIT7 ;
	P2OUT |= BIT2 ;

	//sets variable to be input values from port 1 and 2
	int val1 = 0 ;
	int val2 = 0 ;
	val1 |= P1IN ;
	val2 |= P2IN ;

	//bit masks to get only needed pit input
	val1 &= BIT7 ;
	val2 &= BIT2 ;

	//checks which button is pressed
	if(!val1 && !val2){
		return GREEN ;
	}
	else if(!val1){
		return RED ;
	}
	else if(!val2){
		return ORANGE ;
	}
	else return 0 ;
}

void configLED1_3(char inbits){
	//select digital IO ports
	P1SEL &= ~(BIT0) ;
	P8SEL &= ~(BIT1|BIT2) ;

	//select pins to be outputs
	P1DIR |= BIT0 ;
	P8DIR |= (BIT1|BIT2) ;

	//sets variables to hold separate bits of inbits
	int bit1 = 0 ;
	int bit2 = 0 ;
	int bit3 = 0 ;

	//sets each variable to be equal to inbits
	bit1 |= inbits ;
	bit2 |= inbits ;
	bit3 |= inbits ;

	//bit masks so that each variable is appropriate bit of inbits
	bit1 &= BIT1 ;
	bit2 &= BIT2 ;
	bit3 &= BIT3 ;

	//sets whether LEDs are on or off
	if(bit1){
		P1OUT |= BIT0 ;
	}
	else{
		P1OUT &= ~(BIT0) ;
	}
	if(bit2 && bit3){
		P8OUT |= (BIT1|BIT2) ;
	}
	else if (bit2){
		P8OUT &= ~BIT2 ;
		P8OUT |= BIT1 ;
	}
	else if(bit3){
		P8OUT &= ~BIT1 ;
		P8OUT |= BIT2 ;
	}
	else{
		P8OUT &= ~(BIT1|BIT2) ;
	}
}

void runtimerA2(void){
	//Use ACLK (TASSEL_!), clock divider of 1 (ID_0)
	//and start timer counting in Up mode (MC_1)
	TA2CTL = TASSEL_1 + MC_1 +ID_0 ;

	TA2CCR0 = 162 ;

	TA2CCTL0 = CCIE ;
}

void stoptimerA2(int i){
	timer = i ;
}

#pragma vector=TIMER2_A0_VECTOR //syntax for declaring ISR
__interrupt void Timer_A2_ISR(void){
	if(leap_cnt <= 195){
		timer++ ;
		leap_cnt++ ;
	}
	else{
		leap_cnt = 0 ;
	}
}

void displayNote(NoteData Notes[], int noteNum){
	GrClearDisplay(&g_sContext) ;
	int i ; //loop Counter
	for(i = noteNum; i < (noteNum +3); i++){
		if(Notes[i].touchPad == XX){
			if(Notes[i].duration == 100){
				GrStringDrawCentered(&g_sContext, "O", AUTO_STRING_LENGTH, 10, (60 - 15*(i - noteNum)), TRANSPARENT_TEXT);
			}
			else{
				GrStringDrawCentered(&g_sContext, "@", AUTO_STRING_LENGTH, 10, (60 - 15*(i - noteNum)), TRANSPARENT_TEXT);
			}
		}
		else if(Notes[i].touchPad == SQUARE){
			if(Notes[i].duration== 100){
				GrStringDrawCentered(&g_sContext, "O", AUTO_STRING_LENGTH, 30, (60 - 15*(i - noteNum)), TRANSPARENT_TEXT);
			}
			else{
				GrStringDrawCentered(&g_sContext, "@", AUTO_STRING_LENGTH, 30, (60 - 15*(i - noteNum)), TRANSPARENT_TEXT);
			}
		}
		else if(Notes[i].touchPad == OCT){
			if(Notes[i].duration== 100){
				GrStringDrawCentered(&g_sContext, "O", AUTO_STRING_LENGTH, 50, (60 - 15*(i - noteNum)), TRANSPARENT_TEXT);
			}
			else{
				GrStringDrawCentered(&g_sContext, "@", AUTO_STRING_LENGTH, 50, (60 - 15*(i - noteNum)), TRANSPARENT_TEXT);
			}
		}
		else if(Notes[i].touchPad == TRI){
			if(Notes[i].duration== 100){
				GrStringDrawCentered(&g_sContext, "O", AUTO_STRING_LENGTH, 70, (60 - 15*(i - noteNum)), TRANSPARENT_TEXT);
			}
			else{
				GrStringDrawCentered(&g_sContext, "@", AUTO_STRING_LENGTH, 70, (60 - 15*(i - noteNum)), TRANSPARENT_TEXT);
			}
		}
		else if(Notes[i].touchPad == CIRCLE){
			if(Notes[i].duration== 100){
				GrStringDrawCentered(&g_sContext, "O", AUTO_STRING_LENGTH, 90, (60 - 15*(i - noteNum)), TRANSPARENT_TEXT);
			}
			else{
				GrStringDrawCentered(&g_sContext, "@", AUTO_STRING_LENGTH, 90, (60 - 15*(i - noteNum)), TRANSPARENT_TEXT);
			}
		}
	}
	GrFlush(&g_sContext) ;
}

